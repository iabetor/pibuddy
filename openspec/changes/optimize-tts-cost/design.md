# Design: 优化 TTS 成本和回复流畅度

## Context

PiBuddy 使用流式处理 LLM 输出：每当提取到一个完整句子，就立即调用 TTS 合成并播放。这种设计有两个优点：
1. **响应快**：用户能快速听到第一句话
2. **体验好**：不需要等待 LLM 完成所有输出

但在工具调用场景下，这种设计会导致问题：
- LLM 先输出"我来帮你查询..."，立即被合成播放
- 然后调用工具，获取结果
- 最后再输出实际答案

这导致 TTS 成本浪费和回复分段过多。

## Goals / Non-Goals

**Goals:**
- 减少工具调用场景下的 TTS 浪费
- 提高回复流畅度
- 保持快速响应的用户体验

**Non-Goals:**
- 不修改流式处理的基本架构
- 不增加复杂的句子缓冲机制（除非必要）

## Decisions

### Decision 1: 优先优化 System Prompt

**Why:**
- 成本最低，风险最小
- 通过提示工程可以直接影响 LLM 行为
- 不需要修改代码逻辑

**Implementation:**
```yaml
# 旧版 prompt
system_prompt: "你是小派...你可以查询天气...回答尽量简短口语化..."

# 新版 prompt（优化）
system_prompt: |
  你是小派，一个运行在树莓派上的智能家庭助手。

  回复原则：
  1. 简洁友好，口语化，适合语音播报
  2. 不要使用 emoji 表情符号
  3. 如果需要调用工具（如查询天气、黄历等），直接调用，不要先说"我来帮你查询..."
  4. 回复要连贯完整，避免分段过多

  你可以：
  - 查询天气、新闻热搜、股票行情
  - 查询农历、黄历、节气、节日
  - 设置闹钟提醒、记录备忘
  - 做数学计算、告诉时间日期
  - 播放音乐（先搜索，再播放）

  音乐播放流程：
  1. 先调用 search_music 搜索
  2. 告诉用户搜索结果（歌名-歌手）
  3. 询问用户播放哪一首
  4. 用户确认后调用 play_music 播放

  你也可以和用户闲聊、讲故事、回答问题。
```

**预期效果:**
- LLM 在需要工具时直接调用，不说"我来帮你..."
- 回复更简洁连贯

### Decision 2: 监控效果，必要时修改代码

**方案 B（备用）：缓冲首句策略**

如果优化 prompt 效果不明显，可以考虑：

```go
// 在 processQuery 中修改流式处理逻辑
for chunk := range textCh {
    // ... 现有逻辑 ...

    // 新增：检测是否有工具调用
    if firstSentence && hasToolCalls(result) {
        // 缓冲第一句话，等工具执行完再播放
        firstSentenceBuffer = sentence
        continue
    }

    // 正常播放
    p.speakText(ctx, sentence)
}
```

**Trade-offs:**
- 优点：能完全避免 TTS 浪费
- 缺点：
  - 增加代码复杂度
  - 可能延迟首句播放（降低响应速度）
  - 需要预测 LLM 是否会调用工具（有难度）

**决策：** 先实施方案 A（优化 prompt），观察效果。如果仍有问题，再考虑方案 B。

## Risks / Trade-offs

### Risk 1: Prompt 优化效果不明显
- **风险**：LLM 可能仍会说"我来帮你..."
- **缓解**：
  - 在 prompt 中更明确地禁止这种行为
  - 提供示例（few-shot learning）
  - 最后考虑方案 B（代码修改）

### Risk 2: 回复过于简短
- **风险**：LLM 可能回复过于简短，缺乏友好性
- **缓解**：
  - 在 prompt 中平衡简洁和友好
  - 保留"可以和用户闲聊"的指示

### Risk 3: 特定场景仍需铺垫
- **风险**：某些复杂场景，铺垫可能有助于理解
- **缓解**：
  - 在 prompt 中说明"简单查询直接回答，复杂操作可适当说明"
  - 保持一定的灵活性

## Implementation Plan

### Phase 1: Prompt 优化（立即实施）
1. 修改 `configs/pibuddy.yaml` 的 system_prompt
2. 测试各种场景（天气、黄历、音乐、闹钟等）
3. 观察 TTS 调用次数和回复流畅度

### Phase 2: 效果评估（1周后）
1. 收集用户反馈
2. 统计 TTS 调用次数变化
3. 评估是否需要方案 B（代码修改）

### Phase 3: 代码优化（如需要）
1. 实现"缓冲首句"策略
2. 添加工具调用预测逻辑
3. 测试和验证

## Success Metrics

- TTS 调用次数减少 > 30%
- 用户满意度提升
- 回复连贯度改善
- 平均响应时间不增加（或增加 < 500ms）
